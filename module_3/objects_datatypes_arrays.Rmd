---
title: "Objects, Data Types, ID Arrays"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is our first real coding lecture. In this and all future such lectures, I highly highly recommend that you work through examples with me as we go along.

## Basic Data Types
Remember from our last lecture that you can use R as a calculator: 
```{r}
# addition
4+5  
```
```{r}
# subtraction
19-17 
```
```{r}
# multiplication
5*3 
```
```{r}
# division
9/38 
```
```{r}
# exponentiation
2^4 
```

<br>
And that you can use it to display and manipulate strings:
```{r}
# display text in the console
print("Hello, World!") 
# select the 3rd-7th characters of the phrase "Hello, World!"
substr("Hello, World!", 3, 7) 
```

<br> 
And that you can test the equality, inequality, or relative size of two statements or numbers:
```{r}
# test the equality of numbers
4 == 2+2 
# test the INequality of numbers
4 != 2+2 

# test the equivalence of phrases
"Hello"=="hello" 
# test the INequivalence of phrases
"Hello"!="hello" 

# size comparisons
3>2 
3<2
3<3

```

<br> 
These three types of operation mirror the three basic ways that data is stored in R. **Numeric** data types are numbers like `7` or `-2` or `3.14159`. **Character** data types, also called **strings**, are letters or phrases enclosed by quotes, like `"Hello, World!"` or `"This is a string"`, or `"3.14159"`. (Yes, if you put a number in quotes it becomes a string!) **Logical** data types, also known as **booleans**, are `TRUE` or `FALSE` values, usually generated as a result of *testing the equivalence* of two objects. 

Get to know these data types well-- programming is all about manipulating them in intricate ways.


## Objects and Variables
So far, you're probably less-than-impressed that R knows how to add two numbers together. Fair. Programming languages like R really start to get powerful when you realize that you can **store** values in named objects called **variables**. 

Let's say your at home, and you want to bake some brownies while you work on your Intro to Data Science homework, but your brownie pan is small so you want to make a batch 2/3 the size it says in the recipe. You could type in the amount of flour you'd need to measure:

```{r}
# the recipe calls for 2 cups of flour, so the number of cups I need is:
2*(2/3)
```

And then type in the amount of butter:
```{r}
# the recipe calls for 8 tablespoons of butter, so the number of tablespoons I need is:
8*(2/3)
```

And then the amount of sugar:
```{r}
# the recipe calls for 1.5 cups of sugar, so the number of cups I need is:
1.5*(2/3)
```

...but you see already how this is getting tedious. We want to do the same thing over and over (multiply a number by 2/3), we just want to change (or, some might say, *vary*) the value of the number we're multiplying. This is exactly what a **variable** is designed for. 

If you're following along with this code in RStudio, look at "Environment" section in the top right corner of the screen. At the moment it should say "Environment is empty"-- what that means is that we haven't *stored* anything as a variable yet. Now, run this:

```{r}
recipe_amount <- 2
```
You should notice two things about running this code. First, it didn't print any *output* to the console. Second, there should now be an entry in the "Environment" section, with the name "recipe_amount" and a value of 2:

[insert screenshot]

So, what have we done? We haven't multiplied anything by anything, but we've created a **variable** named "recipe_amount", set its value equal to 2 (the number of cups of flour specified in the recipe), and *saved* it in the R environment. The `<-` symbol is what we use in R to **assign** a value to a variable name. 

Now that we have this variable, we can do math (or anything else) to it just the same as we would to the initial number. Here, we want to multiply it by 2/3, so we can write:

```{r}
recipe_amount * 2/3
```

As you can see, this gives us the correct number of cups of flour to use: 1 & 1/3.

So at this point, we have a two-line script that looks like this:
```{r, eval=F}
recipe_amount <- 2
recipe_amount * 2/3
```

Now, if we want to figure out how many tablespoons of butter we need, all we have to do is change the 2 to an 8 and run those two lines of code again, and the computer will print out the correct number. 

What if, in two weeks, you buy a much bigger baking pan, so now you instead want to multiply the original recipe by 2.5? You could change your two-line script to a three-line script that looks like this:

```{r}
recipe_amount <- 2
recipe_multiplier <- 2.5
recipe_amount * recipe_multiplier
```
Now you've expanded your script to *two* variables, two stored values, and you can change either of them as needed to get your ingredient quantities!

This may seem like a silly example--it would still be a bit tedious to change the value of the `recipe_amount` variable over and over again, and it would probably be easier just to use an actual calculator, but there are two things I want you to take away from this:

1. It's possible to *store* values in memory as named variables;
2. It would be super convenient if you could convert *all* the ingredient amounts in one go, like if you could sort of "loop" through the list of ingredients and multiply each one by your `recipe_multiplier` variable. Hmmm (*foreshadowing*)...


```
<br>
Also note: You can use variables to create other variables. So, if I wanted to save the final amount of some ingredient, I could do:
```{r}
final_quantity <- recipe_amount * recipe_multiplier
```
<br>
You can make string variables or boolean variables as well as numeric variables:
```{r}
# String variables
string_variable <- "Hello, World!"
print(string_variable)
substr(string_variable, 3, 7)

# Boolean variables
boolean_variable <- 2==4
boolean_variable
```
<br>

Notice that I can name variables whatever I want. I called our first variable `recipe_amount`, but I could have called it `goldfish` and the code would have understood it just fine:
```{r}
# generate a variable named "goldfish"
goldfish <- 8 
# check if that variable, multiplied by 4, equals 32
goldfish*4
```
<br>
Also notice that R is extremely sensitive to small typos, like letter ordering or capitalization:
```{r, error=T}
print(goldfish)
print(Goldfish)
print(godlfish)
```
<br>
Naming things whatever we want is exciting, but we should use this power responsibly. Variable names (and object names more broadly), should be clear, concise, and descriptive of the thing they represent. See the coding best practices page for more details. 

I've thrown the word "object" around a few times without really describing what it is. An **object** is anything that you can manipulate in a programming language. They're usually named, and you can see them in your `Environment` panel. Variables are objects, but so are lots of other things (like arrays, which we'll learn about in the next section). 

## 1-Dimensional Arrays

So far we've just looked at objects that represent single things, like the number 8 or the word "cat" or the value "TRUE". What if we instead want a *collection* of things, like a list of numbers or words or true/false values (such as, perhaps, a list of recipe quantities)? Well, we'd use an array. 

**"Array"** is a generic term for a group of things. Arrays can have many different formats, dimensions, and names. We're going to be focusing on a type of 1-dimensional array in R called a **vector**. (1-dimensional means that there's just one list of things-- a 2-dimensional array would be like a spreadsheet or a dataset, we'll get to those later.) 

### Making Vectors
There are a few different ways to make vectors in R; the most manual way is using a fuction called `c()`. `c()` takes all the elements you give it (separated by commas) and *combines* elements into a vector (the `c` is for "combine"). Let's look at a few examples:

```{r}
numeric_vector <- c(1, 2, 3)
print(numeric_vector)

string_vector <- c("cat", "dog", "horse")
print(string_vector)

boolean_vector <- c(F, T, T, F)  # note: you can just write "T" or "F" instead of "TRUE" and "FALSE"; it achieves the same thing.
print(boolean_vector)
```

<br>
Notice that all the *members* of each of these vectors is the same type. For vectors, each element has to be of the same type. If you try to make a vector with multiple types, it will coerce them to all be the same:

```{r}
# strings "beat" numerics
c(3, "cat", 4, "dog") 
# numerics "beat" logicals (in binary arithmetic, 1 equals "True" and 0 equals "False", hence the conversions)
c(7, T, F, 2) 
# strings "beat" logicals
c("Hello", F, "World!", T, T) 
```
<br>

There are a few other ways to make vectors that are useful to know. If you want a series of numbers, you can use the `:` operator and then you just have to specify the first and last number you want:
```{r}
# vector of integers from 1 to 10
1:10 
# integers from 57 to 65
57:65 
# it can go backwards, too!
10:1 
# it's fine with decimal numbers, but the interval between values will always be 1
5.5:8.5 
```
<br> 
If you want a series of numbers at intervals other than 1, use the `seq()` function. It needs three values: your starting number, your final number, and the interval between values:
```{r}
# this is the same as "1:10"
seq(1, 10, 1) 
# 1:10, but only keeping every other number
seq(1, 10, 2) 
# 10:100, only keeping every tenth number
seq(10, 100, 10) 
```
<br> 
If you want to repeat the same set of values many times, use the `rep()` function. It needs two things: the vector of values you want to repeat, and how many times you want to repeat them:
```{r}
# repeat the sequence 1:5 three times
rep(1:5, 3) 
# repeat this two-element string vector twice
rep(c("Hello", "World!"), 2) 
# repeat this three-element boolean vector four times
rep(c(F, F, T), 4) 
```

### Subsetting Vectors
<br> 
Let's say you make a vector using one of the methods above:
```{r}
example_vector <- rep(1:5, 2)
```
And you want to know what the seventh element is. This is called an **indexing** operation. In our example, it's easy to count and discover that the seventh element is a 2:
```{r, echo=F}
rep(1:5, 2)
```
But you can do this much more quickly with code. R uses brackets `[]` for indexing operations. So, if you wanted to know the seventh element of `example_vector`, you would run:
```{r}
example_vector[7]
```
<br>
you can use this same syntax to query a range of values:
```{r}
# show the 7th-9th members of example_vector
example_vector[7:9] 
```
<br>
or (using more vector notation) to find a few specific values:
```{r}
# shows the 5th, 7th, and 9th members of example_vector
example_vector[c(5, 7, 9)] 
```
<br>
Each of these outputs is itself a vector, and you can save it as such:
```{r}
# saves the 5th, 7th, and 9th members of example_vector to a new vector
subset_vector <- example_vector[c(5, 7, 9)] 
```

### Lengthening, Shortening, and Combining Vectors

Shoot! What if you wanted `example_vector` to have one last "1" at the end? You can **append** more elements to vectors using the same function we used to create them: `c()`! 

```{r}
example_vector <- c(example_vector, 1)
print(example_vector)
```
<br>
**IMPORTANT: Notice that I assigned our new vector the name `example_vector` in order to *update* it. If I had just done this:**
```{r, echo=F, results='hide'}
example_vector <- rep(1:5, 2)
```
```{r}
c(example_vector, 1)
```
**it would have printed the result to the screen, but would *not* have updated the values in `example_vector`**:
```{r}
print(example_vector)
```
**BE VIGILANT!**
<br>
<br>
Ok, now you have your new `example_vector` with the 1 at the end:
```{r, echo=F}
example_vector <- c(example_vector, 1)
print(example_vector)
```

Shoot! You just realized you don't want that last 5 in there. You can get rid of it using `[]`, the same as an indexing operation, but putting a `-` sign before the index value:
```{r}
example_vector <- example_vector[-10]
print(example_vector)
```
<br>
Notice that you remove values based on their *position* in the line, not based on their *value*. Doing `example_vector[-5]` would have removed the *first* `5` from the vector, because it's in the `fifth spot`. 
<br>
<br>
What if you want to combine `example_vector` with some other vector? Our friend `c()` is here to help us again!
```{r}
other_vector <- c(50, 27, 84)
new_vector <- c(example_vector, other_vector)
print(new_vector)
```
<br>
Ok, now that we're armed with variables and arrays, we can get into the powerhouses of programming: logic and loops! 



## Side Note: Functions

I've used the term "function" a few times in this page, but haven't really defined it yet. A **function** is a piece of code that *performs an action* on other objects. If variables and arrays are the nouns of the coding world, functions are the verbs.

Functions have **arguments**, which are the input variables, and they produce **outputs**. Let's think back to that function `seq()`, which takes three arguments: a starting value, a stopping value, and the interval between values:
```{r}
seq(1, 10, 2)
```
<br>
Its *output* is a vector of values: the starting value, then the starting value plus the interval value, and so on until you hit the stopping value. But function outputs don't have to be vectors: they can be just about anything. The function `print()`, which we've seen several times before, doesn't strictly speaking "return" any output at all-- it just displays values on the screen. Other functions return single values, 2D arrays, or even other functions! 

Each argument in a function has a name, but you don't need to use them so long as you keep arguments in the same order that the function is expecting to see them. However, if you do choose to use argument names, you can list things in whatever order you like. These three lines of code are equivalent:
```{r}
seq(1, 10, 2)
seq(from=1, to=10, by=2)
seq(to=10, by=2, from=1)
```
<br>
We won't get too deep into the nitty gritty of functions in this course, but I want you to have some idea of what they are and when you're using them. 




